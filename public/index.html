<!DOCTYPE html>
<!-- saved from url=(0039)https://homicide-dashboard.netlify.app/ -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tracking Jackson's Homicides</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="">
    
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

    <style>
        /* --- BASE STYLES & COLOR THEME --- */
        :root {
            --body-bg: #e9ecef;
            --content-bg: #ffffff;
            --text-color: #212529;
            --header-bg: #ffffff;
            --header-border: #dee2e6;
            --banner-bg: #d9534f; 
            --banner-text: #ffffff;
            --legend-bg: #f8f9fa;
            --legend-border: #dee2e6;
            --legend-label-text: #495057;
            --input-border: #ced4da;
            --input-bg: #ffffff;
            --chart-title-text: #343a40;
            --chart-axis-text: #6c757d;
            --chart-grid-color: rgba(0, 0, 0, 0.1);
            --chart-legend-text: #333;
            --footer-bg: #f8f9fa;
            --footer-text: #6c757d;
            --footer-link: #0056b3;
            --tooltip-bg: rgba(33, 37, 41, 0.9);
            --tooltip-text: #f8f9fa;
            --map-placeholder-bg: #adb5bd;
            --boundary-city-color: #000000; 
            --boundary-ccid-color: #E65100; 
            --rank-banner-rank1-bg: #d9534f; 
            --rank-banner-rank2to5-bg: #f0ad4e; 
            --rank-banner-ranklow-bg: #5cb85c; 
            --rank-banner-error-bg: #777777; 
            --percentage-increase-color: #d9534f; 
            --percentage-decrease-color: #5cb85c; 
            --percentage-neutral-color: var(--text-color); 
        }
        
        html {
            height: 100%;
        }
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            margin: 0; 
            padding: 0;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--body-bg);
            color: var(--text-color);
            -webkit-text-size-adjust: 100%; 
            text-size-adjust: 100%;
        }
        
        .dashboard-container {
            width: 100%; 
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            background-color: var(--content-bg);
        }

        /* --- LAYOUT & COMPONENT STYLES --- */
        .header {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap; 
            gap: 20px; 
            padding: 10px 15px; 
            background-color: var(--header-bg);
            border-bottom: 2px solid var(--header-border);
            flex-shrink: 0;
        }

        .header-logo-main img, .header-logo-secondary img { 
            max-height: 60px; 
            width: auto; 
            object-fit: contain; 
            vertical-align: middle; 
        } 
        
        .count-banner { 
            color: var(--banner-text);
            text-align: center; padding: 8px 15px; 
            font-size: 1.8em; 
            font-weight: bold;
            flex-shrink: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); 
            background-color: var(--banner-bg);
        }
        
        .ranking-banner {
            font-size: 1.1em;
            padding: 0;
            background-color: var(--rank-banner-error-bg);
            overflow: hidden;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            color: var(--banner-text);
            font-weight: bold;
            flex-shrink: 0;
        }

        .ticker-wrap {
            display: inline-block;
            padding: 8px 0;
            animation: ticker 40s linear infinite;
        }
        
        .ticker-item {
            display: inline-block;
            padding: 0 2rem;
            color: var(--banner-text);
        }
        .ticker-item span {
            font-weight: normal;
            opacity: 0.9;
        }

        @keyframes ticker {
            0% { transform: translateX(0); }
            100% { transform: translateX(-50%); }
        }
        
        .main-content-area { 
            display: flex; 
            flex-direction: row;
            flex: 1 1 auto;
            background-color: var(--content-bg); 
        }
        
        .legend-container {
            width: 30%; 
            max-width: 400px; 
            padding: 15px; 
            border-right: 1px solid var(--legend-border);
            overflow-y: auto; background-color: var(--legend-bg); 
            display: flex; 
            flex-direction: column; 
            flex-shrink: 0;
            box-sizing: border-box;
        }
        
        .filter-columns-wrapper { 
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .filter-group { 
            margin-bottom: 10px; 
            box-sizing: border-box;
        } 
        
        .filter-group.circumstance-filter, .filter-group.percentage-change-display { 
            grid-column: 1 / -1; 
            margin-top: 10px; 
        }

        .filter-group.percentage-change-display {
            margin-top: 15px; 
        }

        .filter-group label.group-label { 
            display: block; margin-bottom: 5px; 
            font-weight: bold;
            font-size: 0.95em; 
            color: var(--legend-label-text); 
        }
        .filter-group select, .filter-group .checkbox-group {
            width: 100%; padding: 10px; 
            border: 1px solid var(--input-border);
            border-radius: 4px; font-size: 1em; 
            box-sizing: border-box; background-color: var(--input-bg); color: var(--text-color);
            min-height: 44px;
        }
        .checkbox-group { 
            max-height: 120px; 
            overflow-y: auto; 
            padding: 8px; 
        }
        .checkbox-group div { margin-bottom: 3px; display: flex; align-items: center;}
        .checkbox-group input[type="checkbox"] { margin-right: 5px; }
        .checkbox-group label { font-weight: normal; font-size: 0.9em; color: var(--legend-label-text);}
        
        #percentageChangeText { 
            text-align: center; 
            font-weight: bold; 
            padding: 12px; 
            background-color: var(--input-bg); 
            border: 1px solid var(--input-border); 
            border-radius: 4px;
            font-size: 1.4em; 
        }

        .map-container { flex-grow: 1; min-height: 500px; }
        #map { height: 100%; width: 100%; background-color: var(--map-placeholder-bg); } 
        
        /* --- Chart and Tab Styles --- */
        .charts-container {
            border-top: 1px solid var(--legend-border);
        }
        .chart-tabs {
            display: flex;
            border-bottom: 1px solid var(--legend-border);
            padding: 0 10px;
        }
        .tab-btn {
            padding: 10px 15px;
            cursor: pointer;
            border: none;
            background-color: transparent;
            font-weight: bold;
            color: var(--text-color);
            border-bottom: 3px solid transparent;
            margin-bottom: -1px; 
        }
        .tab-btn.active {
            border-bottom-color: var(--banner-bg);
            color: var(--banner-bg);
        }
        .chart-tab-content {
            display: none;
            flex-wrap: wrap;
        }
        .chart-tab-content.active {
            display: flex;
        }

        .chart-box { 
            padding: 20px; 
            position: relative; 
            display: flex; 
            flex-direction: column; 
            box-sizing: border-box; 
        }
        
        #main-trends-content .chart-box { width: 50%; }
        #main-trends-content .chart-box:first-child { border-right: 1px solid var(--legend-border); }

        #details-content .chart-box { width: 50%; }
        #details-content .chart-box:nth-child(odd) { border-right: 1px solid var(--legend-border); }
        #details-content .chart-box:nth-child(1),
        #details-content .chart-box:nth-child(2) { border-bottom: 1px solid var(--legend-border); }


        .chart-box h4 { text-align: center; margin-top: 0; margin-bottom: 15px; font-size: 1.1em; color: var(--chart-title-text); }
        .chart-canvas-container { flex-grow: 1; position: relative; min-height: 220px; } 

        .footer {
            padding: 10px 15px; text-align: center; 
            font-size: 0.8em; color: var(--footer-text); 
            background-color: var(--footer-bg);
            border-top: 1px solid var(--header-border); flex-shrink: 0;
        }
        .footer p { margin: 5px 0; } 
        .footer a { color: var(--footer-link); text-decoration: none; } 
        .footer a:hover { text-decoration: underline; }

        /* --- PLUGIN & MODAL STYLES --- */
        .leaflet-tooltip {
            background-color: var(--tooltip-bg); 
            color: var(--tooltip-text);
            border: none; box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
            border-radius: 4px; padding: 10px 15px; 
            font-size: 1em; 
        }
        .leaflet-tooltip p { margin: 0; padding: 3px 0; } 
        .leaflet-tooltip p:first-child { font-size: 1.1em; font-weight: bold; margin-bottom: 5px; }
        .leaflet-tooltip hr { border: 0; border-top: 1px solid #666; margin: 5px 0; }
        .leaflet-tooltip b { color: var(--tooltip-text); font-weight: bold; } 

        .leaflet-control-layers { background: var(--content-bg); border: 1px solid var(--legend-border); }
        .leaflet-control-layers-selector, .leaflet-control-layers label, .leaflet-control-layers label span { color: var(--text-color); }

        .modal-overlay {
            display: none; position: fixed;
            z-index: 1000; left: 0; top: 0;
            width: 100%; height: 100%;
            overflow: auto; background-color: rgba(0,0,0,0.5); 
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: #fefefe; padding: 20px;
            border: 1px solid #888; border-radius: 8px;
            width: 90%; max-width: 600px; position: relative;
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);
        }
        .modal-close {
            color: #aaa; position: absolute; top: 10px; right: 20px;
            font-size: 28px; font-weight: bold; line-height: 1;
            cursor: pointer;
        }
        .modal-close:hover, .modal-close:focus { color: black; text-decoration: none; }
        .modal-content h2 { margin-top: 0; color: #333; }
        .modal-content p { line-height: 1.6; color: #555; }
        
        /* --- RESPONSIVE STYLES --- */
        @media (max-width: 768px) {
            .main-content-area { 
                flex-direction: column; 
            }
            .legend-container { 
                width: 100%; 
                max-width: none; 
                border-right: none; 
                border-bottom: 2px solid var(--legend-border); 
                flex-shrink:0;
            } 
            .map-container { 
                height: 450px; 
                flex-grow: 0; 
                flex-shrink: 0; 
            } 
            .filter-columns-wrapper {
                grid-template-columns: 1fr;
            }
            .chart-tab-content { flex-direction: column; } 
            .chart-box { 
                width: 100% !important; 
                padding: 15px; 
                border-right: none !important; 
            }
            #details-content .chart-box:not(:last-child),
            #main-trends-content .chart-box:not(:last-child) { 
                border-bottom: 1px solid var(--legend-border); 
            }
            .chart-box:last-child {
                border-bottom: none;
            }
            .header-logo-main img, .header-logo-secondary img { max-height: 45px; } 
        }
    </style>
</head>
<body>
<div class="dashboard-container">
   <div class="header">
        <div class="header-logo-main">
            <img id="trackingLogoImg" src="data:image/png;base64,iVBORI=" alt="Tracking Jackson's Homicides Logo">
        </div>
        <div class="header-logo-secondary">
            <img id="wlbtLogoImg" src="data:image/png;base64,iVBORwAAElFTkSuQmCC" alt="WLBT Logo">
        </div>
    </div>

    <div class="count-banner" id="homicideCountBanner">2025 COUNT: ...</div>
    <div class="ranking-banner" id="rankingBanner">
        <div class="ticker-wrap" id="tickerWrap">
            </div>
    </div>

    <div class="main-content-area">
        <div class="legend-container">
            <div class="filter-columns-wrapper">
                <div class="filter-group year-filter">
                    <label class="group-label" for="yearFilter">Year:</label>
                    <div id="yearFilter" class="checkbox-group"></div>
                </div>
                <div class="filter-group agency-filter">
                    <label class="group-label" for="agencyFilter">Agency:</label>
                    <div id="agencyFilter" class="checkbox-group"></div>
                </div>
                <div class="filter-group circumstance-filter">
                    <label class="group-label" for="circumstanceFilter">Circumstance:</label>
                    <select id="circumstanceFilter"></select>
                </div>
                 <div class="filter-group percentage-change-display">
                    <label class="group-label">Trend vs. Last Year:</label>
                    <div id="percentageChangeText"></div>
                </div>
            </div> 
            </div>
        <div class="map-container">
            <div id="map"></div>
        </div>
    </div>

    <div class="charts-container">
        <div class="chart-tabs">
            <button class="tab-btn active" data-tab="main-trends-content">Key Trends</button>
            <button class="tab-btn" data-tab="details-content">Detailed Breakdowns</button>
        </div>

        <div id="main-trends-content" class="chart-tab-content active">
            <div class="chart-box">
                <h4>Cumulative Homicides by Year</h4>
                <div class="chart-canvas-container">
                    <canvas id="homicideTrendsChart"></canvas>
                </div>
            </div>
            <div class="chart-box">
                <div style="display: flex; justify-content: center; align-items: center; gap: 10px; margin-bottom: 15px;">
                    <h4 style="margin: 0;">Homicides by Year</h4>
                    <button id="toggleYearRangeBtn" style="padding: 3px 10px; font-size: 0.8em; cursor: pointer; border-radius: 4px; border: 1px solid #ccc; background-color: #f0f0f0;">Show All Years</button>
                </div>
                <div class="chart-canvas-container">
                    <canvas id="homicidesByYearChart"></canvas>
                </div>
            </div>
        </div>

        <div id="details-content" class="chart-tab-content">
            <div class="chart-box">
                <h4>Victims by Age Group</h4>
                <div class="chart-canvas-container">
                    <canvas id="victimsByAgeChart"></canvas>
                </div>
            </div>
            <div class="chart-box">
                <h4>Victims by Race</h4>
                <div class="chart-canvas-container">
                    <canvas id="victimsByRaceChart"></canvas>
                </div>
            </div>
            <div class="chart-box">
                <h4>Homicides by Circumstance</h4>
                <div class="chart-canvas-container">
                    <canvas id="homicidesByCircumstanceChart"></canvas>
                </div>
            </div>
            <div class="chart-box">
                <h4>Homicides by Agency</h4>
                <div class="chart-canvas-container">
                    <canvas id="homicidesByAgencyChart"></canvas>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <p><a href="#" id="openAboutModal">About the Data</a></p>
        <p>Data Sources: JPD, DPS, Hinds County, JSUPD | Design/Layout: C.J. LeMaster</p>
    </div>

    <div id="aboutDataModal" class="modal-overlay">
        <div class="modal-content">
            <span class="modal-close" id="closeAboutModal">×</span>
            <h2>Our Methodology</h2>

<p><strong>Homicide</strong> refers to one person killing another, regardless of intent. Unlike <strong>murder</strong>, which implies intent, some homicides—such as <strong>justified or officer-involved deaths</strong>—are not crimes. That’s why the number of homicides is typically higher than murders.</p>

<p><strong>WLBT uses the same criteria as the Jackson Police Department:</strong> we count all homicides, including justified ones, but exclude most vehicular homicides unless officially classified as such. Our numbers come from <strong>JPD releases</strong>, <strong>confirmations from police and the coroner</strong>, and <strong>reports from other lead agencies</strong> when killings occur within Jackson city limits.</p>

<p><strong>Because we count all homicides that happen in Jackson</strong>—not just those investigated by JPD—our totals may differ from those reported by individual agencies. For example, <strong>Capitol Police and Jackson State officers</strong> have led several homicide investigations in recent years.</p>

<p><strong>Our data may be updated</strong> as new cases surface. In 2023, we discovered JPD had not disclosed 24 homicide cases, prompting a correction in our reporting. Since then, <strong>we regularly request updates</strong> to prevent similar omissions.</p>

<p>Some details—like <strong>age, race, or exact location</strong>—may be missing due to gaps in law enforcement reporting. Still, <strong>we work to verify and include as much information as possible</strong> to help the public and investigators.</p>        </div>
    </div>
</div>
    <script>
        // --- Configuration ---
        const HOMICIDE_DATA_API_URL = './data/homicide.json'; 
        const CITY_COMPARISON_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vQyiORmxzjhdAokYzM0NhcTjAk1e3hJp81B5OCG03XcPnUaSVrCRiwIXmah2iPSHFaaWbSoKKwFA1Uc/pub?gid=0&single=true&output=csv'; 
        const JACKSON_POPULATION = 143709; 

        const CURRENT_YEAR = new Date().getFullYear();
        const PREVIOUS_YEAR = CURRENT_YEAR - 1;
        const START_YEAR_DATA = 2016;
        const MAP_CENTER = [32.2988, -90.1848]; 
        const MAP_ZOOM = 12; 

        const JACKSON_CITY_LIMITS_GEOJSON_URL = 'https://dl.dropbox.com/scl/fi/9ct9dki2dsg68iyr7gley/City-Boundaries.geojson?rlkey=vjrtpish5tixdeygp1ja5h7fq&st=fyrqfq4x&dl=1'; 
        const CCID_GEOJSON_URL = 'https://dl.dropbox.com/scl/fi/qz4hkchrk6zonnbr1i5pl/New-CCID-2025.geojson?rlkey=26misdl15h1vgxxj28fzfqhjw&st=82688i24&dl=1'; 
        
        const AGENCY_CATEGORIES = {
            JPD: 'JPD',
            CAPITOL_POLICE: 'Capitol Police',
            OTHER: 'Other Agencies' 
        };
        
        const agencyColors = {
            [AGENCY_CATEGORIES.JPD]: 'rgba(0, 123, 255, 0.7)',
            [AGENCY_CATEGORIES.CAPITOL_POLICE]: 'rgba(255, 193, 7, 0.7)',
            [AGENCY_CATEGORIES.OTHER]: 'rgba(40, 167, 69, 0.7)',
            'Historical': 'rgba(108, 117, 125, 0.7)'
        };

        // --- Historical Data (1976-2015) ---
        const historicalHomicideData = [
            { year: 1976, total: 40 }, { year: 1977, total: 47 }, { year: 1978, total: 33 }, { year: 1979, total: 55 }, { year: 1980, total: 42 },
            { year: 1981, total: 49 }, { year: 1982, total: 57 }, { year: 1983, total: 42 }, { year: 1984, total: 34 }, { year: 1985, total: 43 },
            { year: 1986, total: 35 }, { year: 1987, total: 54 }, { year: 1988, total: 51 }, { year: 1989, total: 49 }, { year: 1990, total: 47 },
            { year: 1991, total: 80 }, { year: 1992, total: 64 }, { year: 1993, total: 84 }, { year: 1994, total: 91 }, { year: 1995, total: 92 },
            { year: 1996, total: 61 }, { year: 1997, total: 64 }, { year: 1998, total: 60 }, { year: 1999, total: 45 }, { year: 2000, total: 39 },
            { year: 2001, total: 50 }, { year: 2002, total: 49 }, { year: 2003, total: 45 }, { year: 2004, total: 53 }, { year: 2005, total: 38 },
            { year: 2006, total: 40 }, { year: 2007, total: 46 }, { year: 2008, total: 63 }, { year: 2009, total: 37 }, { year: 2010, total: 41 },
            { year: 2011, total: 52 }, { year: 2012, total: 63 }, { year: 2013, total: 50 }, { year: 2014, total: 61 }, { year: 2015, total: 54 }
        ];

        // --- Global State ---
        let allHomicideData = [];
        let cityComparisonData = []; 
        let filteredHomicideDataForMap = []; 
        let map;
        let markersLayer = L.layerGroup();
        let heatLayer; 
        let cityLimitsLayer; 
        let ccidLayer;       
        let overlayLayersControl; 
        let currentMapTileLayer; 
        let showAllYears = false; // State for the year chart toggle

        let homicidesByYearChartInstance, homicideTrendsChartInstance, victimsByAgeChartInstance,
            victimsByRaceChartInstance, homicidesByCircumstanceChartInstance, homicidesByAgencyChartInstance;

        // --- Function Definitions (in correct order) ---

        function setupModal() {
            const modal = document.getElementById("aboutDataModal");
            const openBtn = document.getElementById("openAboutModal");
            const closeBtn = document.getElementById("closeAboutModal");

            openBtn.onclick = function(e) { e.preventDefault(); modal.style.display = "flex"; }
            closeBtn.onclick = function() { modal.style.display = "none"; }
            window.onclick = function(event) { if (event.target == modal) { modal.style.display = "none"; } }
            window.addEventListener('keydown', function (event) { if (event.key === 'Escape') { modal.style.display = 'none' }});
        }

        function setupTabs() {
            const tabContainer = document.querySelector('.chart-tabs');
            tabContainer.addEventListener('click', (event) => {
                if (event.target.classList.contains('tab-btn')) {
                    const tabName = event.target.dataset.tab;
                    openTab(event, tabName);
                }
            });
        }
        
        function setupChartToggles() {
            const toggleBtn = document.getElementById('toggleYearRangeBtn');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    showAllYears = !showAllYears;
                    toggleBtn.textContent = showAllYears ? 'Show Recent Years' : 'Show All Years';
                    updateHomicidesByYearChart();
                });
            }
        }

        function openTab(evt, tabName) {
            document.querySelectorAll('.chart-tab-content').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tabName).classList.add('active');
            evt.currentTarget.classList.add('active');
        }

        async function fetchDataAndProcess(url, isMainHomicideData = false) { 
            let rawData;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Network response was not ok for ${url}`);
                
                if (isMainHomicideData) { 
                    const text = await response.text();
                    // Clean potential trailing commas before parsing
                    const cleanedText = text.trim().replace(/,\s*\]\s*\}\s*$/, ']}');
                    rawData = JSON.parse(cleanedText);
                } else { 
                    const csvText = await response.text(); 
                    rawData = csvToJSON(csvText);
                }
            } catch (error) {
                console.error(`Failed to fetch or parse data from ${url}:`, error);
                if(isMainHomicideData) {
                    console.log("Using placeholder homicide data due to fetch error.");
                    rawData = getPlaceholderData();
                } else {
                     console.log("Using placeholder city data due to fetch error.");
                    rawData = getPlaceholderCityData();
                }
            }
            
            if (isMainHomicideData) {
                if (!rawData || !rawData.headers || !rawData.entries) return [];
                const headers = rawData.headers.map(h => String(h).trim().toLowerCase());
                const getHeaderIndex = (names) => {
                    for (let name of names) {
                        const index = headers.indexOf(name.toLowerCase());
                        if (index !== -1) return index;
                    }
                    return -1;
                };

                const indices = {
                    victim: getHeaderIndex(['Victim']), age: getHeaderIndex(['Age']), race: getHeaderIndex(['Race']),
                    sex: getHeaderIndex(['Sex']), circumstance: getHeaderIndex(['Circumstance']), date: getHeaderIndex(['Date']),
                    address: getHeaderIndex(['Address', 'Location']), agency: getHeaderIndex(['Investigating Agency', 'Agency']),
                    precinct: getHeaderIndex(['Precinct']), lat: getHeaderIndex(['Latitude', 'Lat']), lon: getHeaderIndex(['Longitude', 'Lon', 'Long']),
                    year: getHeaderIndex(['Year']), month: getHeaderIndex(['Month']), day: getHeaderIndex(['Day'])
                };

                return rawData.entries.map((entry, i) => {
                    let dateObj;
                    const dateStr = entry[indices.date] ? String(entry[indices.date]).trim() : '';

                    // First attempt: Parse the 'Date' column
                    if (dateStr) {
                        if (dateStr.includes('-')) {
                            dateObj = new Date(dateStr + "T00:00:00");
                        } else if (dateStr.includes('/')) {
                            const parts = dateStr.split('/');
                            if (parts.length === 3) {
                                dateObj = new Date(parts[2], parseInt(parts[0]) - 1, parts[1]);
                            }
                        }
                    }
                    
                    // Fallback attempt: If the first attempt failed or was incomplete, use Year, Month, Day columns
                    if (!dateObj || isNaN(dateObj.getTime())) {
                        const year = parseInt(entry[indices.year]);
                        const month = parseInt(entry[indices.month]);
                        const day = parseInt(entry[indices.day]);
                        if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
                            dateObj = new Date(year, month - 1, day);
                        }
                    }

                    const lat = parseFloat(entry[indices.lat]);
                    const lon = parseFloat(entry[indices.lon]);

                    if (!dateObj || isNaN(dateObj.getTime()) || isNaN(lat) || isNaN(lon)) {
                        console.warn(`Discarding record ${i+1} due to invalid data:`, {date: dateStr, year: entry[indices.year], month: entry[indices.month], day: entry[indices.day], lat: entry[indices.lat], lon: entry[indices.lon]});
                        return null;
                    }
                    
                    return {
                        Victim: entry[indices.victim] || 'N/A', Age: entry[indices.age] ? parseInt(entry[indices.age]) : null, 
                        Race: entry[indices.race] || 'N/A', Sex: entry[indices.sex] || 'N/A',
                        Circumstance: entry[indices.circumstance] || 'N/A', Date: dateObj.toISOString().split('T')[0],
                        DisplayDate: dateStr, Address: entry[indices.address] || 'N/A', 
                        'Investigating Agency': entry[indices.agency] || 'N/A', Precinct: entry[indices.precinct] || 'N/A',
                        Latitude: lat, Longitude: lon, Year: dateObj.getFullYear(), 
                    };
                }).filter(Boolean);
            } else { 
                if (!rawData) return [];
                return rawData.map(d => ({
                    City: d.City ? String(d.City).trim() : null,
                    Homicides: d.Homicides ? parseInt(String(d.Homicides).trim()) : null,
                    Population: d.Population ? parseInt(String(d.Population).trim()) : null,
                })).filter(d => d.City && d.Homicides >= 0 && d.Population > 0);
            }
        }
        
        function logProcessedDataSummary(data, dataType) { console.log(`Processed ${data.length} items for ${dataType}`); }
        
        function csvToJSON(csv) { 
            const lines = csv.replace(/\r/g, '').split('\n');
            const result = [];
            if (lines.length < 1) return result;
            const headers = lines[0].split(',').map(h => h.trim());
            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue; 
                const obj = {};
                const values = lines[i].split(',');
                headers.forEach((header, index) => {
                    obj[header] = values[index] ? values[index].trim() : '';
                });
                result.push(obj);
            }
            return result;
        }

        function getPlaceholderData() { 
            return {
                headers: ["Date", "Location", "Victim", "Agency", "Precinct", "Age", "Sex", "Race", "Circumstance", "Latitude", "Longitude"],
                entries: [
                    [`01/15/${CURRENT_YEAR}`, "123 Main St, Jackson, MS", 'John Doe', "JPD", "1", 30, "Male", "Black", "Argument", 32.3010, -90.1850],
                    [`02/20/${CURRENT_YEAR}`, "456 Oak Ave, Jackson, MS", 'Jane Smith', "Capitol Police", "2", 25, "Female", "White", "Robbery", 32.2950, -90.1900]
                ]
            };
        }
        function getPlaceholderCityData() { 
            return [
                { City: 'St. Louis, MO', Homicides: 190, Population: 286578 },
                { City: 'Baltimore, MD', Homicides: 330, Population: 569931 },
                { City: 'New Orleans, LA', Homicides: 260, Population: 369749 },
                { City: 'Detroit, MI', Homicides: 300, Population: 620376 },
                { City: 'Memphis, TN', Homicides: 340, Population: 621056 },
            ];
        }
        
        function initMap() {
            map = L.map('map').setView(MAP_CENTER, MAP_ZOOM);
            updateMapTiles(); 
            markersLayer.addTo(map); 
            heatLayer = L.heatLayer([], { radius: 25 });
            loadBoundaryLayers();
        }
        function updateMapTiles() { 
            if (!map) return;
            if (currentMapTileLayer) {
                map.removeLayer(currentMapTileLayer);
            }
            currentMapTileLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
                maxZoom: 18
            });
            currentMapTileLayer.addTo(map);
        }
        function populateFiltersForMap(isInitialLoad = false) {
            const yearContainer = document.getElementById('yearFilter');
            
            if (isInitialLoad) {
                const allYearsFromData = [...new Set(allHomicideData.map(d => d.Year))].sort((a, b) => b - a);
                const yearsForFilter = allYearsFromData.filter(y => y >= START_YEAR_DATA && y <= CURRENT_YEAR);
                populateCheckboxFilter('yearFilter', yearsForFilter, [CURRENT_YEAR], handleYearFilterChange);
            }

            const selectedYears = Array.from(yearContainer.querySelectorAll('input:checked')).map(cb => parseInt(cb.value));
            const dataForDependentFilters = allHomicideData.filter(d => selectedYears.includes(d.Year));

            const agencyContainer = document.getElementById('agencyFilter');
            const circumstanceSelect = document.getElementById('circumstanceFilter');
            const previouslySelectedAgencies = Array.from(agencyContainer.querySelectorAll('input:checked')).map(cb => cb.value);
            const previouslySelectedCircumstance = circumstanceSelect.value;
            
            const agenciesToShow = [...new Set(dataForDependentFilters.map(d => d['Investigating Agency']))].filter(Boolean).sort();
            populateCheckboxFilter('agencyFilter', agenciesToShow, agenciesToShow, updateDashboard);

            const circumstancesToShow = [...new Set(dataForDependentFilters.map(d => d.Circumstance))].filter(Boolean).sort();
            circumstanceSelect.innerHTML = '<option value="">All Circumstances</option>';
            circumstancesToShow.forEach(c => {
                const option = new Option(c, c);
                if (c === previouslySelectedCircumstance && circumstancesToShow.includes(c)) {
                    option.selected = true;
                }
                circumstanceSelect.add(option);
            });
            circumstanceSelect.removeEventListener('change', updateDashboard);
            circumstanceSelect.addEventListener('change', updateDashboard);
        }
        function handleYearFilterChange() {
            populateFiltersForMap(false);
            updateDashboard();
        }
        function populateCheckboxFilter(elementId, values, defaultSelected, changeCallback) {
            const container = document.getElementById(elementId);
            const previouslySelected = Array.from(container.querySelectorAll('input:checked')).map(cb => cb.value);
            container.innerHTML = ''; 
            values.forEach(val => {
                const div = document.createElement('div');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `${elementId}_${String(val).replace(/\s+/g, '_')}`;
                checkbox.value = val;
                checkbox.checked = defaultSelected.includes(val) || previouslySelected.includes(String(val));
                checkbox.addEventListener('change', changeCallback);
                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = val;
                div.append(checkbox, label);
                container.appendChild(div);
            });
        }

        function updateCurrentYearHomicideCount() {
            const currentYearHomicides = allHomicideData.filter(d => d.Year === CURRENT_YEAR).length;
            document.getElementById('homicideCountBanner').innerText = `${CURRENT_YEAR} COUNT: ${currentYearHomicides}`;
        }
        function updateRankingBanner() {
            const banner = document.getElementById('rankingBanner');
            const tickerWrap = document.getElementById('tickerWrap');
            if (!banner || !tickerWrap) return;

            const jacksonHomicidesThisYear = allHomicideData.filter(d => d.Year === CURRENT_YEAR).length;
            const jacksonRate = (jacksonHomicidesThisYear / JACKSON_POPULATION) * 100000;

            if (!cityComparisonData || cityComparisonData.length === 0) {
                tickerWrap.innerHTML = `<div class="ticker-item">City comparison data not available.</div>`;
                return;
            }

            const citiesWithRates = cityComparisonData.map(city => ({
                name: city.City,
                rate: (city.Homicides / city.Population) * 100000
            }));

            citiesWithRates.push({ name: 'Jackson, MS', rate: jacksonRate });
            citiesWithRates.sort((a, b) => b.rate - a.rate);

            const jacksonRank = citiesWithRates.findIndex(c => c.name === 'Jackson, MS') + 1;
            
            let bannerColorVar = '--rank-banner-error-bg'; 
            if (jacksonRank === 1) bannerColorVar = '--rank-banner-rank1-bg';
            else if (jacksonRank >= 2 && jacksonRank <= 5) bannerColorVar = '--rank-banner-rank2to5-bg';
            else if (jacksonRank > 5) bannerColorVar = '--rank-banner-ranklow-bg';
            banner.style.backgroundColor = getComputedStyle(document.documentElement).getPropertyValue(bannerColorVar).trim();

            const tickerItems = ["Top 5 U.S. Cities by Homicide Rate"];
            
            const top5 = citiesWithRates.slice(0, 5);
            top5.forEach((c, i) => {
                tickerItems.push(`${i + 1}. ${c.name} <span>(${c.rate.toFixed(1)})</span>`);
            });

            const isJacksonInTop5 = top5.some(c => c.name === 'Jackson, MS');
            if (!isJacksonInTop5 && jacksonRank > 0) {
                 tickerItems.push(`... | ${jacksonRank}. Jackson, MS <span>(${jacksonRate.toFixed(1)})</span>`);
            }
            
            const tickerText = tickerItems.join(' &nbsp; | &nbsp; ');
            
            tickerWrap.innerHTML = `<div class="ticker-item">${tickerText}</div><div class="ticker-item">${tickerText}</div>`;
        }
        function updateMapDisplay() { 
            const selectedYears = Array.from(document.querySelectorAll('#yearFilter input:checked')).map(cb => parseInt(cb.value));
            const selectedAgencies = Array.from(document.querySelectorAll('#agencyFilter input:checked')).map(cb => cb.value);
            const selectedCircumstance = document.getElementById('circumstanceFilter').value;
            
            filteredHomicideDataForMap = allHomicideData.filter(d => 
                selectedYears.includes(d.Year) &&
                selectedAgencies.includes(d['Investigating Agency']) &&
                (!selectedCircumstance || d.Circumstance === selectedCircumstance)
            );

            markersLayer.clearLayers();
            const heatPoints = [];
            const visibleMarkers = []; 

            filteredHomicideDataForMap.forEach(d => {
                const latLng = [d.Latitude, d.Longitude];
                heatPoints.push(latLng);

                const marker = L.circleMarker(latLng, {
                    radius: 6, fillColor: "#d9534f", color: "#c82333", weight: 1, opacity: 1, fillOpacity: 0.8
                });
                
                let tooltipContent = `<p style="margin: 0 0 5px 0; font-weight: bold; font-size: 1.1em;">${d.Victim || 'Unknown Victim'}</p><hr style="border: 0; border-top: 1px solid #666; margin: 5px 0;">`;
                if (d.Age && d.Age !== 'N/A') tooltipContent += `<p style="margin: 5px 0;"><b>Age:</b> ${d.Age}</p>`;
                if (d.Race && d.Race !== 'N/A') tooltipContent += `<p style="margin: 5px 0;"><b>Race:</b> ${d.Race}</p>`;
                if (d.Sex && d.Sex !== 'N/A') tooltipContent += `<p style="margin: 5px 0;"><b>Sex:</b> ${d.Sex}</p>`;
                if (d.DisplayDate && d.DisplayDate !== 'N/A') tooltipContent += `<p style="margin: 5px 0;"><b>Date:</b> ${d.DisplayDate}</p>`;
                if (d.Address && d.Address !== 'N/A') tooltipContent += `<p style="margin: 5px 0;"><b>Address:</b> ${d.Address}</p>`;
                if (d.Circumstance && d.Circumstance !== 'N/A') tooltipContent += `<p style="margin: 5px 0;"><b>Circumstance:</b> ${d.Circumstance}</p>`;
                if (d['Investigating Agency'] && d['Investigating Agency'] !== 'N/A') tooltipContent += `<p style="margin: 5px 0;"><b>Agency:</b> ${d['Investigating Agency']}</p>`;
                if (d.Precinct && d.Precinct !== 'N/A') tooltipContent += `<p style="margin: 5px 0;"><b>Precinct:</b> ${d.Precinct}</p>`;

                marker.bindTooltip(tooltipContent, { sticky: true });
                markersLayer.addLayer(marker);
                visibleMarkers.push(marker); 
            });

            heatLayer.setLatLngs(heatPoints);

            if (visibleMarkers.length > 0 && map.hasLayer(markersLayer)) {
                map.fitBounds(L.featureGroup(visibleMarkers).getBounds().pad(0.1)); 
            } else {
                map.setView(MAP_CENTER, MAP_ZOOM);
            }
        }
        
        function getChartOptions(tooltipCallback) { 
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-axis-text').trim();
            const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid-color').trim();

            return {
                responsive: true, maintainAspectRatio: false,
                scales: {
                    x: { stacked: true, ticks: { color: textColor }, grid: { color: gridColor } },
                    y: { stacked: true, beginAtZero: true, ticks: { color: textColor }, grid: { color: gridColor } }
                },
                plugins: {
                    legend: { position: 'top' },
                    tooltip: { 
                        mode: 'index', intersect: false,
                        callbacks: { label: tooltipCallback }
                    }
                }
            };
        }

        function getTrendChartOptions() { 
             const textColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-axis-text').trim();
            const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid-color').trim();
            const titleColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-title-text').trim();

            return {
                 responsive: true, maintainAspectRatio: false,
                    scales: {
                        y: { 
                            beginAtZero: true, 
                            title: {display: true, text: 'Cumulative Homicides', color: titleColor},
                            ticks: { color: textColor },
                            grid: { color: gridColor }
                        },
                        x: {
                            type: 'time',
                            time: { unit: 'month', parser: 'yyyy-MM-dd', tooltipFormat: 'MMM dd', displayFormats: { month: 'MMM' } },
                            title: {display: true, text: 'Month', color: titleColor},
                            ticks: { color: textColor },
                            grid: { color: gridColor }
                        }
                    },
                    plugins: { 
                        legend: { position: 'top' }, 
                        tooltip: { mode: 'index', intersect: false } 
                    }
            };
        }
        
        function updateHomicidesByYearChart() {
            const chartOptions = getChartOptions(() => {}); // Base options, callbacks will be customized per view

            if (showAllYears) {
                // --- VIEW 1: Show All Years (1976-Present) as a simple total bar chart ---
                const yearlyTotals = {};
                // Combine historical and modern data to get a single total per year
                historicalHomicideData.forEach(d => {
                    yearlyTotals[d.year] = d.total;
                });
                allHomicideData.forEach(d => {
                    yearlyTotals[d.Year] = (yearlyTotals[d.Year] || 0) + 1;
                });

                const allSortedYears = Object.keys(yearlyTotals).map(Number).sort((a, b) => a - b);
                const yearsToDisplay = allSortedYears.filter(y => y <= CURRENT_YEAR);
                const totalsData = yearsToDisplay.map(year => yearlyTotals[year] || 0);

                const datasets = [{
                    label: 'Total Homicides',
                    data: totalsData,
                    backgroundColor: agencyColors['Historical'],
                }];

                // Configure for a simple, non-stacked bar chart
                chartOptions.scales.x.stacked = false;
                chartOptions.scales.y.stacked = false;
                chartOptions.plugins.legend.display = false; // Only one dataset, so no legend needed
                chartOptions.plugins.tooltip.callbacks.label = (context) => `Total: ${context.parsed.y}`;

                const ctx = document.getElementById('homicidesByYearChart').getContext('2d');
                if (homicidesByYearChartInstance) homicidesByYearChartInstance.destroy();
                homicidesByYearChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: { labels: yearsToDisplay, datasets },
                    options: chartOptions
                });

            } else {
                // --- VIEW 2: Show Recent Years (2016-Present) with agency breakdown ---
                const yearlyTotals = {};
                const yearsToDisplay = [];
                // Initialize years from START_YEAR_DATA to current year
                for (let y = START_YEAR_DATA; y <= CURRENT_YEAR; y++) {
                    yearsToDisplay.push(y);
                    yearlyTotals[y] = {
                        [AGENCY_CATEGORIES.JPD]: 0,
                        [AGENCY_CATEGORIES.CAPITOL_POLICE]: 0,
                        [AGENCY_CATEGORIES.OTHER]: 0
                    };
                }

                // Populate with data from modern records
                allHomicideData.forEach(d => {
                    if (d.Year >= START_YEAR_DATA) {
                        const agency = d['Investigating Agency'];
                        if (agency === AGENCY_CATEGORIES.JPD) yearlyTotals[d.Year][AGENCY_CATEGORIES.JPD]++;
                        else if (agency === AGENCY_CATEGORIES.CAPITOL_POLICE) yearlyTotals[d.Year][AGENCY_CATEGORIES.CAPITOL_POLICE]++;
                        else yearlyTotals[d.Year][AGENCY_CATEGORIES.OTHER]++;
                    }
                });

                const datasets = Object.keys(AGENCY_CATEGORIES).map(key => {
                    const category = AGENCY_CATEGORIES[key];
                    return {
                        label: category,
                        data: yearsToDisplay.map(year => yearlyTotals[year][category]),
                        backgroundColor: agencyColors[category],
                    };
                });
                
                // Configure for a stacked bar chart
                chartOptions.scales.x.stacked = true;
                chartOptions.scales.y.stacked = true;
                chartOptions.plugins.legend.display = true;
                chartOptions.plugins.tooltip.callbacks.label = (context) => {
                    const label = context.dataset.label || '';
                    const value = context.raw;
                    let total = 0;
                    context.chart.data.datasets.forEach(ds => { total += ds.data[context.dataIndex]; });
                    const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                    return `${label}: ${value} (${percentage}%)`;
                };
                
                const ctx = document.getElementById('homicidesByYearChart').getContext('2d');
                if (homicidesByYearChartInstance) homicidesByYearChartInstance.destroy();
                homicidesByYearChartInstance = new Chart(ctx, { type: 'bar', data: { labels: yearsToDisplay, datasets }, options: chartOptions });
            }
        }


        function updateHomicideTrendsChart() {
            const chartOptions = getTrendChartOptions(); 

            const getRunningTotalData = (yearToFilter, dataSet) => {
                const yearData = dataSet.filter(d => d.Year === yearToFilter && d.Date)
                    .sort((a, b) => new Date(a.Date) - new Date(b.Date));

                const chartDataPoints = [];
                const commonAxisYear = 2000; 
                let cumulativeCount = 0;
                let homicideDataIndex = 0;
                
                let loopEndDate = (yearToFilter === CURRENT_YEAR) ? new Date() : new Date(yearToFilter, 11, 31);
                
                for (let dLoop = new Date(yearToFilter, 0, 1); dLoop <= loopEndDate; dLoop.setDate(dLoop.getDate() + 1)) {
                    const currentLoopDayFormatted = dLoop.toISOString().split('T')[0];
                    
                    while(homicideDataIndex < yearData.length && yearData[homicideDataIndex].Date <= currentLoopDayFormatted) {
                        cumulativeCount++;
                        homicideDataIndex++;
                    }
                    
                    chartDataPoints.push({
                        x: `${commonAxisYear}-${(dLoop.getMonth() + 1).toString().padStart(2, '0')}-${dLoop.getDate().toString().padStart(2, '0')}`,
                        y: cumulativeCount 
                    });
                }
                
                if (chartDataPoints.length === 0 || chartDataPoints[0].x !== `${commonAxisYear}-01-01`) {
                    chartDataPoints.unshift({ x: `${commonAxisYear}-01-01`, y: 0 });
                }

                return chartDataPoints;
            };

            const dataForCurrentYear = getRunningTotalData(CURRENT_YEAR, allHomicideData);
            const dataForPreviousYear = getRunningTotalData(PREVIOUS_YEAR, allHomicideData);

            const ctx = document.getElementById('homicideTrendsChart').getContext('2d');
            if (homicideTrendsChartInstance) {
                homicideTrendsChartInstance.destroy();
            }
            homicideTrendsChartInstance = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [
                        { label: String(CURRENT_YEAR), data: dataForCurrentYear, borderColor: '#dc3545', tension: 0.1, fill: false, pointRadius: 2, pointHoverRadius: 4 },
                        { label: String(PREVIOUS_YEAR), data: dataForPreviousYear, borderColor: '#007bff', tension: 0.1, fill: false, pointRadius: 2, pointHoverRadius: 4 }
                    ]
                },
                options: chartOptions 
            });
        }

        function updateDemographicCharts() {
            const tooltipCallback = (context) => {
                let label = context.label || '';
                let value = context.raw;
                const total = context.chart.data.datasets[0].data.reduce((sum, val) => sum + val, 0);
                const percentage = total > 0 ? ((value / total) * 100).toFixed(1) : 0;
                return `${label}: ${value} (${percentage}%)`;
            };
            const chartOptions = getChartOptions(tooltipCallback);
            chartOptions.plugins.legend.display = false;

            const ageGroups = { '0-17': 0, '18-29': 0, '30-49': 0, '50+': 0, 'Unknown': 0 };
            filteredHomicideDataForMap.forEach(d => {
                const age = d.Age;
                if (age === null || isNaN(age)) {
                    ageGroups['Unknown']++;
                } else if (age <= 17) {
                    ageGroups['0-17']++;
                } else if (age <= 29) {
                    ageGroups['18-29']++;
                } else if (age <= 49) {
                    ageGroups['30-49']++;
                } else {
                    ageGroups['50+']++;
                }
            });

            const ageCtx = document.getElementById('victimsByAgeChart').getContext('2d');
            if (victimsByAgeChartInstance) victimsByAgeChartInstance.destroy();
            victimsByAgeChartInstance = new Chart(ageCtx, {
                type: 'bar',
                data: {
                    labels: Object.keys(ageGroups),
                    datasets: [{
                        label: 'Victims by Age Group',
                        data: Object.values(ageGroups),
                        backgroundColor: '#5bc0de'
                    }]
                },
                options: chartOptions
            });
        }
        
        function updatePercentageChangeDisplay() {
            const percentageChangeDiv = document.getElementById('percentageChangeText');
            if (!percentageChangeDiv || !allHomicideData || allHomicideData.length === 0) {
                percentageChangeDiv.innerText = 'Data N/A';
                percentageChangeDiv.style.color = getComputedStyle(document.documentElement).getPropertyValue('--percentage-neutral-color');
                return;
            }

            const today = new Date();
            const dayOfYear = (Date.UTC(today.getFullYear(), today.getMonth(), today.getDate()) - Date.UTC(today.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1000;

            const getCountUpToDay = (year, day) => {
                return allHomicideData.filter(d => {
                    if (d.Year !== year || !d.Date) return false;
                    const itemDate = new Date(d.Date + 'T00:00:00'); // Ensure consistent time
                    const itemDayOfYear = (Date.UTC(itemDate.getFullYear(), itemDate.getMonth(), itemDate.getDate()) - Date.UTC(itemDate.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1000;
                    return itemDayOfYear <= day;
                }).length;
            };

            const currentYearCountToDate = getCountUpToDay(CURRENT_YEAR, dayOfYear);
            const previousYearCountToDate = getCountUpToDay(PREVIOUS_YEAR, dayOfYear);
            
            let percentageChangeText = "N/A";
            let textColorVar = '--percentage-neutral-color';

            if (previousYearCountToDate > 0) {
                const change = ((currentYearCountToDate - previousYearCountToDate) / previousYearCountToDate) * 100;
                if (change > 0) {
                    percentageChangeText = `+${change.toFixed(0)}%`;
                    textColorVar = '--percentage-increase-color';
                } else if (change < 0) {
                    percentageChangeText = `${change.toFixed(0)}%`;
                    textColorVar = '--percentage-decrease-color';
                } else {
                    percentageChangeText = "0%";
                }
            } else if (currentYearCountToDate > 0) {
                percentageChangeText = `+${currentYearCountToDate} (from 0)`; 
                textColorVar = '--percentage-increase-color';
            } else { 
                 percentageChangeText = "0% (YTD)";
            }
            percentageChangeDiv.innerText = percentageChangeText;
            percentageChangeDiv.style.color = getComputedStyle(document.documentElement).getPropertyValue(textColorVar).trim();
        }
        
        function updateVictimsByRaceChart() {
            const counts = filteredHomicideDataForMap.reduce((acc, d) => {
                const race = d.Race || 'Unknown';
                acc[race] = (acc[race] || 0) + 1;
                return acc;
            }, {});
            if (victimsByRaceChartInstance) victimsByRaceChartInstance.destroy();
            victimsByRaceChartInstance = new Chart(document.getElementById('victimsByRaceChart'), {
                type: 'pie',
                data: { labels: Object.keys(counts), datasets: [{ data: Object.values(counts) }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'right' }}}
            });
        }

        function updateHomicidesByCircumstanceChart() {
            const counts = filteredHomicideDataForMap.reduce((acc, d) => {
                const circumstance = d.Circumstance || 'Unknown';
                acc[circumstance] = (acc[circumstance] || 0) + 1;
                return acc;
            }, {});
            if (homicidesByCircumstanceChartInstance) homicidesByCircumstanceChartInstance.destroy();
            homicidesByCircumstanceChartInstance = new Chart(document.getElementById('homicidesByCircumstanceChart'), {
                type: 'bar',
                data: { labels: Object.keys(counts), datasets: [{ label: 'Count', data: Object.values(counts), backgroundColor: '#6f42c1' }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { display: false }}}
            });
        }

        function updateHomicidesByAgencyChart() {
            const counts = filteredHomicideDataForMap.reduce((acc, d) => {
                const agency = d['Investigating Agency'] || 'Unknown';
                acc[agency] = (acc[agency] || 0) + 1;
                return acc;
            }, {});
            if (homicidesByAgencyChartInstance) homicidesByAgencyChartInstance.destroy();
            homicidesByAgencyChartInstance = new Chart(document.getElementById('homicidesByAgencyChart'), {
                type: 'pie',
                data: { labels: Object.keys(counts), datasets: [{ data: Object.values(counts) }] },
                options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'right' }}}
            });
        }
        
        function updateDashboard() {
            updateCurrentYearHomicideCount();
            updateRankingBanner();
            updatePercentageChangeDisplay();
            updateMapDisplay();
            updateHomicidesByYearChart(); 
            updateHomicideTrendsChart();
            updateDemographicCharts();
            updateVictimsByRaceChart();
            updateHomicidesByCircumstanceChart();
            updateHomicidesByAgencyChart();
        }

        function loadBoundaryLayers(){
            const baseLayers = { 
                "Markers": markersLayer,
                "Heatmap": heatLayer
            };
            const overlayMaps = {}; 
            let cityLimitsAttempted = false; 
            let ccidAttempted = false;       
            
            const tryBuildLayerControl = () => {
                if (cityLimitsAttempted && ccidAttempted) {
                    updateBoundaryLayerStyles(); 
                    updateLayerControl(baseLayers, overlayMaps);
                }
            };

            if (JACKSON_CITY_LIMITS_GEOJSON_URL && JACKSON_CITY_LIMITS_GEOJSON_URL !== 'YOUR_JACKSON_CITY_LIMITS_GEOJSON_URL_HERE') {
                fetch(JACKSON_CITY_LIMITS_GEOJSON_URL)
                    .then(response => {
                        if (!response.ok) { throw new Error(`HTTP error! status: ${response.status} for Jackson GeoJSON`); }
                        return response.json();
                    })
                    .then(geojson => {
                        cityLimitsLayer = L.geoJSON(geojson); 
                        overlayMaps["Jackson City Limits"] = cityLimitsLayer;
                        cityLimitsLayer.addTo(map); 
                    })
                    .catch(error => {
                        console.error('Error loading Jackson city limits GeoJSON. URL attempted:', JACKSON_CITY_LIMITS_GEOJSON_URL, error);
                    })
                    .finally(() => {
                        cityLimitsAttempted = true;
                        tryBuildLayerControl();
                    });
            } else {
                console.warn("Jackson City Limits GeoJSON URL is a placeholder or not provided. Boundary not loaded.");
                cityLimitsAttempted = true; 
                tryBuildLayerControl();
            }
            
            if (CCID_GEOJSON_URL && CCID_GEOJSON_URL !== 'YOUR_CCID_GEOJSON_URL_HERE') {
                fetch(CCID_GEOJSON_URL)
                    .then(response => {
                        if (!response.ok) { throw new Error(`HTTP error! status: ${response.status} for CCID GeoJSON`); }
                        return response.json();
                    })
                    .then(geojson => {
                        ccidLayer = L.geoJSON(geojson); 
                        overlayMaps["CCID Boundary"] = ccidLayer;
                        ccidLayer.addTo(map); 
                    })
                    .catch(error => {
                        console.error('Error loading CCID GeoJSON. URL attempted:', CCID_GEOJSON_URL, error);
                    })
                    .finally(() => {
                        ccidAttempted = true;
                        tryBuildLayerControl();
                    });
            } else {
                 console.warn("CCID GeoJSON URL is a placeholder or not provided. Boundary not loaded.");
                 ccidAttempted = true; 
                 tryBuildLayerControl();
            }
        }
        function updateLayerControl(baseLayers, overlayMaps) {
            if (overlayLayersControl) {
                map.removeControl(overlayLayersControl);
            }
            overlayLayersControl = L.control.layers(baseLayers, overlayMaps).addTo(map);
        }

        function updateBoundaryLayerStyles() { 
            const cityColor = getComputedStyle(document.documentElement).getPropertyValue('--boundary-city-color').trim();
            const ccidColor = getComputedStyle(document.documentElement).getPropertyValue('--boundary-ccid-color').trim();

            const cityStyle = { color: cityColor, weight: 3, opacity: 0.85, fillOpacity: 0.0 }; 
            const ccidStyle = { color: ccidColor, weight: 4, opacity: 0.9, fillOpacity: 0.25 }; 

            if (cityLimitsLayer && map.hasLayer(cityLimitsLayer)) {
                cityLimitsLayer.setStyle(cityStyle);
            }
            if (ccidLayer && map.hasLayer(ccidLayer)) {
                ccidLayer.setStyle(ccidStyle);
            }
        }
        
        function displayErrorInCharts(errorMessage) {
            const chartIds = ['homicidesByYearChart', 'homicideTrendsChart', 'victimsByAgeChart', 'victimsByRaceChart', 'homicidesByCircumstanceChart', 'homicidesByAgencyChart'];
            chartIds.forEach(id => {
                const canvas = document.getElementById(id);
                if (canvas) {
                    const ctx = canvas.getContext('2d');
                    if (window[id + 'Instance']) { window[id + 'Instance'].destroy(); }
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.font = "16px Arial";
                    ctx.fillStyle = "red";
                    ctx.textAlign = "center";
                    ctx.fillText(errorMessage, canvas.width / 2, canvas.height / 2);
                }
            });
        }

        // --- Main Execution Block ---
        document.addEventListener('DOMContentLoaded', async () => {
            initMap(); 
            setupModal();
            setupTabs();
            setupChartToggles();

            document.getElementById('homicideCountBanner').innerText = `${CURRENT_YEAR} COUNT: Loading...`;
            document.querySelector('.ranking-banner .ticker-wrap').innerHTML = '<div class="ticker-item">City Ranking: Loading...</div>';
            document.getElementById('percentageChangeText').innerText = 'Calculating...';

            try {
                const [homicideDataResult, cityDataResult] = await Promise.all([
                    fetchDataAndProcess(HOMICIDE_DATA_API_URL, true), 
                    fetchDataAndProcess(CITY_COMPARISON_CSV_URL, false) 
                ]);

                allHomicideData = homicideDataResult;
                cityComparisonData = cityDataResult;

                logProcessedDataSummary(allHomicideData, "Homicide Data");
                if (cityComparisonData && cityComparisonData.length > 0) {
                    logProcessedDataSummary(cityComparisonData, "City Comparison Data");
                }

                populateFiltersForMap(true); 
                updateDashboard(); 
                if (map) { 
                    map.invalidateSize();
                }
            } catch (error) {
                console.error("Fatal Error initializing dashboard:", error);
                document.getElementById('homicideCountBanner').innerText = 'Error loading data.';
                document.querySelector('.ranking-banner .ticker-wrap').innerHTML = '<div class="ticker-item">City Ranking: Error</div>';
                document.getElementById('percentageChangeText').innerText = 'Error calculating.';
                displayErrorInCharts("Failed to load data.");
            }
        });
    </script>
</body>
</html>
